# sample10.md

## 構造体の配列

### 構造体の配列について

構造体も配列にできます。方法は今までと同様です。
次は、student型で10個の要素を持つ構造体変数の配列を宣言する例です。

```c
/* 構造体変数の配列 */
student data[10];
```

使い方も、これまでの配列とまったく同じです。
次は、要素番号を指定して構造体配列の要素にアクセスする例です。

```c
/* 構造体配列の要素にアクセス */
data[1].year = 3;
strcpy(data[1].name, "MARIO");
```

そのほかの点も、これまでの配列の使い方と同様です。

#### 別の書き方

構造体の配列があるということは、それは内部でポインタ変数を使っているということです。
したがって、前項で説明した以外の書き方、つまり、ポインタ変数風に書くこともできるのです。
すなわち、次の3つは同じ意味になるのです。

```c
(*data).year
data->year
data[0].year
```

### 構造体配列の引数

構造体配列を引数にして関数に渡すこともできますが、
その場合には、これまでの配列のような渡し方になります。
すなわち、構造体配列の最初のアドレスを渡す形になります。

受け取った関数では、今までの配列の引数と同様に扱えます。
次の関数は、指定された数だけstudent型の中身を表示します。

```c
/* 指定された数だけstudent型の中身を表示 */
void student_print(sudent data[], int count)
{
    int i;

    for(i = 0; i < count; i++) {
        printf("[学年]:%d\n", data[i].year);
        printf("[クラス]:%d\n", data[i].clas);
        printf("[出席番号]:%d\n", data[i].number);
        printf("[名前]:%s\n", data[i].name);
        printf("[身長]:%f\n", data[i].stature);
        printf("[体重]:%f\n", data[i].weight);
    }

    return;
}
```

この場合は、配列を渡した時と同じような振る舞いになります。
渡された先で構造体変数の中身を変更すると呼び出し元も変更されます。
