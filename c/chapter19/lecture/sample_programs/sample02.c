/* sample02.c */

/* 動的配列の要素数を拡大する
 * malloc関数によって、好きな要素数の動的配列を作ることができます。
 * しかし、これでは、最初に述べた、配列の要素数を変更出来ない、
 * という問題は、完全に解決されたとは言えません。
 * そこで、要素数を変更する、realloc(リアロック)関数が用意されています。
 * realloc関数の使い方は、次の通りです。
 *
 * -realloc関数----------------------------------
 *  新しいポインタ変数 = realloc(以前のポインタ変数, 必要なメモリのバイトサイズ);
 * ----------------------------------------------
 *
 * 以前のポインタ変数には、malloc関数で確保したメモリのアドレスを指定します。
 * realloc関数は、中身を維持したまま、新しいサイズのメモリを確保します。
 * 新しいポインタ変数には、拡張されたメモリのアドレスが返されますが、
 * 特別な理由がなければ、以前のポインタ変数と同じ変数を指定できます。
 *
 * 次のプログラムは、realloc関数で動的配列の要素数を変更します。
 */

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int * heap;
    heap = (int *)malloc(sizeof(int) * 10); /* まずint型のポインタ変数heapに要素数10個分の配列を確保 */
    heap = (int *)realloc(heap, sizeof(int) * 100); /* realloc関数を用いて、配列の要素数を100個分に変更 */

    free(heap);

    return 0;
}

/*
 * realloc関数で要素数を10個から100個に増加させています。
 *
 * -呼び出し回数を減らそう-----------------------
 * realloc関数を何回も呼び出すとメモリが散らかって来ます。
 * このような状態をフラグメンテーションと呼び、不安定になります。
 * 初めのmalloc関数である程度大きめに確保しておき、
 * realloc関数を呼び出す場合も、一回で大きめに確保するべきです。
 * ----------------------------------------------
 */

/* メモリリークとの戦い
 * 実のところ、malloc関数について、説明することはこれしかありません。
 * malloc関数で必要な大きさの配列を作り、
 * 不要になったらfree関数で解放する、たったこれだけです。
 * しかし、これこそが、C言語最大の問題でもあるのです。
 *
 * 動的メモリ(malloc関数で作成した配列)が不要になったときに、
 * free関数でメモリを解放することを忘れると、
 * そのメモリは使われもしないままずっと残り続けることになり、
 * いわゆるメモリリークとなってしまいます。
 *
 * メモリリークという単語は読者の方も聞いたことがあるでしょう。
 * また、パソコンやスマホを再起動せずに長時間使っていると、だんだん遅くなってくる、
 * という現象は、皆さんも経験したことがあると思われます。
 * これが、動的メモリの解放忘れ、すなわち、free関数の呼び出し忘れなのです。
 *
 * 今回紹介したようなシンプルな例であれば、free関数の呼び出しを忘れないことは簡単です。
 * しかし、大規模(なんなら超大規模)なプログラムでは、一転して、悪夢のように大変なことになります。
 * 使われているメモリと、もう不要になったメモリを区別することは、極めて困難なのです。
 *
 * 事実上、C言語やその拡張版のC++言語ではこの問題をスマートに解決することは出来ておらず、
 * 膨大かつ徹底したテストによって、なんとか対策しているのが現状です。
 *
 * そのため、Java言語など、ガベージコレクションという、
 * 自動的にメモリを解放してくれる機能をそなえたプログラミング言語が登場し、幅広く使用されています。
 *
 * -ガベージコレクション-------------------------
 * 使用されているメモリを自動的に監視することで、
 * メモリリークを解決する機能。
 * ほとんどのメモリリークを自動的に解決してくれるため、
 * 現代のアプリ開発では、この機能を備えた言語を使用することが多くなりました。
 *
 * ただし、メモリの利用効率上のムダが多くなってしまう弱点も抱えています。
 * ----------------------------------------------
 *
 * 上記のように、ガベージコレクションはどうしてもムダが多くなってしまうことから、
 * Rust言語という、メモリの自動解放と、メモリの効率利用を両立できる言語も登場しました。
 * Rust言語は、今もっとも期待されているプログラミング言語でもあります。
 *
 * -Rust言語-------------------------------------
 * 所有権システムにより、メモリリークに対して、根本的な対策を行った言語。
 * とても雑に言えば、「メモリリークするプログラムは、コンパイルエラーになる」言語。
 *
 * メモリの利用効率をまったくムダにすることなく、
 * ほぼ完全なメモリリーク対策ができるが、
 * ちょっとしたミスでもコンパイルできなくなってしまうため、
 * プログラムの記述するのがかなり疲れるプログラミング言語です。
 * ----------------------------------------------
 */

